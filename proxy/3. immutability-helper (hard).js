/*
  Задача: LeetCode 2691. Immutability Helper

  Описание:
  Создание клонов неизменяемых объектов с незначительными изменениями может быть утомительным процессом.
  Необходимо реализовать класс ImmutableHelper, который будет служить инструментом для этой задачи.

  Конструктор:
  - Принимает неизменяемый объект obj, который является JSON-объектом или массивом.

  Метод:
  - Класс должен иметь единственный метод produce, принимающий функцию-мутатора (mutator).
  - Метод produce возвращает копию объекта obj с применёнными изменениями.
  - Функция mutator получает в качестве аргумента проксированную версию объекта obj, что позволяет выполнять "видимые" изменения,
    при этом оригинальный объект obj не изменяется.

  Особенности функции mutator:
  - Всегда возвращает undefined.
  - Никогда не обращается к несуществующим ключам.
  - Никогда не удаляет ключи (например, delete obj.key).
  - Никогда не вызывает методы на проксированном объекте (например, push, shift и т.д.).
  - Никогда не присваивает ключам значения, являющиеся объектами (например, proxy.x = {}).

  Примечание по тестированию:
  Решение будет оцениваться по разнице между возвращённым объектом и исходным obj, так как полноценное сравнение может оказаться слишком затратным по времени.

  Примеры:

  1. Пример 1:
    Вход:
      obj = {"val": 10},
      mutators = [
        proxy => { proxy.val += 1; },
        proxy => { proxy.val -= 1; }
      ]
    Выход:
      [ {"val": 11}, {"val": 9} ]
    Объяснение:
      const helper = new ImmutableHelper({ val: 10 });
      helper.produce(proxy => { proxy.val += 1; }); // возвращает { "val": 11 }
      helper.produce(proxy => { proxy.val -= 1; }); // возвращает { "val": 9 }

  2. Пример 2:
    Вход:
      obj = {"arr": [1, 2, 3]},
      mutators = [
        proxy => {
          proxy.arr[0] = 5;
          proxy.newVal = proxy.arr[0] + proxy.arr[1];
        }
      ]
    Выход:
      [ {"arr": [5, 2, 3], "newVal": 7} ]
    Объяснение:
      В массиве было произведено два изменения: первый элемент изменён на 5, затем добавлен новый ключ "newVal" со значением 7.

  3. Пример 3:
    Вход:
      obj = {"obj": {"val": {"x": 10, "y": 20}}},
      mutators = [
        proxy => {
          let data = proxy.obj.val;
          let temp = data.x;
          data.x = data.y;
          data.y = temp;
        }
      ]
    Выход:
      [ {"obj": {"val": {"x": 20, "y": 10}}} ]
    Объяснение:
      Значения ключей "x" и "y" были обменены.

  Ограничения:
  - 2 <= JSON.stringify(obj).length <= 4 * 10^5
  - Общее количество вызовов метода produce() меньше 10^5
*/


// Объяснение решения
//  1. Proxy для записи изменений. При вызове метода produce создаётся прокси-объект, который перехватывает все чтения и записи.
//     Если вызывается сеттер (set), то изменение фиксируется в специальной структуре AccessHistory.
//     Это позволяет «видимо» изменять объект, при этом оригинальный объект не модифицируется.
//
//  2. Запись истории изменений. Каждый узел «истории» (экземпляр AccessHistory) хранит либо записанное значение,
//     если по данному пути была произведена установка, либо карту дочерних узлов для отслеживания вложенных изменений.
//
//  3. Применение мутаций. После вызова функции‑мутатора выполняется очистка истории от неиспользуемых веток (функция pruneHistory)
//     и затем формируется новый объект — функция mergeChanges создаёт поверхностную копию исходного объекта,
//     применяя оттуда зафиксированные изменения.
// Глубокое копирование по необходимости. Возвращается новый объект, в котором скопированы только изменённые части,
// остальные ссылки остаются на исходные неизменные объекты.

// ---------------------------------------------------------------------
// Класс AccessHistory предназначен для хранения информации об изменениях.
// Каждая его инстанция представляет "узел" в дереве отслеживания изменений,
// где:
//  - this.value хранит новое значение, если для текущего узла было осуществлено изменение.
//  - this.props – Map для отслеживания изменений во вложенных свойствах.
// Корневой history.value никогда не меняется в этой реализации — он остаётся undefined.
//  1. Корневой history.value никогда не меняется в этой реализации — он остаётся undefined.
//  2. На уровне корня вы никогда не делаете proxy = … (перехват происходит только для proxy.someProp = …, а не для присвоения переменной proxy).
// 3. Соответственно, в accessHistory.value (корневом) нет ни одного места, где бы его перезаписывали.
/*
  AccessHistory (root)
  ├─ value: undefined
  └─ props:
    ├─ "user" → AccessHistory
    │    ├─ value: undefined
    │    └─ props:
    │       ├─ "name" → AccessHistory
    │       │    ├─ value: "Bob"
    │       │    └─ props: {}
    │       └─ "age" → AccessHistory
    │            ├─ value: undefined    // прочитано, но не изменено
    │            └─ props: {}
    └─ "meta" → AccessHistory
          ├─ value: undefined
          └─ props:
            └─ "info" → AccessHistory
                  ├─ value: { key: 1 }
                  └─ props: {}
*/
// ---------------------------------------------------------------------
class AccessHistory {
  constructor() {
    // Изначально, если значение не изменялось, this.value равно undefined.
    // Например, если свойству "val" не присваивали новое значение, его history.value останется undefined.
    // Таким образом, если по пути до свойства уже был совершен заменяющий вызов, мы не углубляемся дальше.
    this.value = undefined;

    // Создаем Map для хранения истории изменений для каждого свойства.
    // Ключ – имя свойства, значение – новый экземпляр AccessHistory для этого свойства.
    // Если изменения произошли во вложенных объектах, то для каждого такого свойства создаётся отдельный узел в props.
    // Пример: Если у исходного объекта есть структура { a: { b: 2 } }
    // и в функции-мутаторе мы делаем изменение proxy.a.b = 5;
    // то:
    //  - Для корня создается history с узлом для свойства a (если его ещё нет).
    //  - Внутри узла a создаётся дочерний узел для свойства b, и его поле value получает значение 5.
    // Таким образом, history фиксирует, что в объекте в поле a.b ожидается новое значение, при этом исходный объект не меняется.
    this.props = new Map();
  }
}

// ---------------------------------------------------------------------
// Функция isObject проверяет, является ли переданное значение объектом.
// При этом null исключается, так как typeof null === "object", но null не подходит.
// ---------------------------------------------------------------------
function isObject(val) {
  // Возвращает true, если val не равен null и тип val равен "object".
  // Пример: isObject({}) → true, isObject([1,2,3]) → true, isObject(null) → false.
  return typeof val === 'object' && val !== null;
}

// ---------------------------------------------------------------------
// Класс ImmutableHelper реализует паттерн иммутабельных изменений.
// Он принимает исходный объект и предоставляет метод produce, 
// в котором через proxy можно "видимо" мутировать объект, не меняя его напрямую.
// После "мутирования" возвращается новый объект с внесёнными изменениями.
// Не 100% глубокое клонирование, а «ленивое» клонирование только по пути изменений.
// Клонируются только те ветки объекта, в которых были реальные изменения. Вот как
// это работает:
//   1. Сбор истории (AccessHistory) – В процессе работы вы мутируете только
//      прокси-версию объекта. Все записи (set) помечаются в дереве истории,
//      а чтения (“get”) подготавливают узлы для возможных правок. – Никакой
//      информации про «нетронутые» ветки в историю не попадает, потому что
//      pruneHistory их вычищает.
//   2. Операция mergeChanges – Сначала проверяется: есть ли полное переприсвоение
//      узла (history.value). Если да — возвращаем новый объект сразу. – Если
//      дочерних записей нет (props.size === 0) — отдаем ссылку на оригинал, без
//      копирования. – Иначе создаём поверхностную копию текущего объекта/массива
//      и в неё рекурсивно «заливаем» лишь те свойства, для которых есть узлы в
//      истории.
// В результате:
//   - Вы не проходите по всему дереву и не клонируете каждый вложенный объект.
//   - Клонируются только те объекты/массивы, где зафиксировано хотя бы одно
//     изменение.
//   - Нетронутые части остаются по тем же ссылкам (structural sharing), что даёт
//     выигрыш по скорости и памяти.
// Благодаря такому «ленивому» клонированию сложность итоговой сборки растёт не с
// размером всего объекта, а с количеством реально изменённых полей.
// ---------------------------------------------------------------------
class ImmutableHelper {
  // Конструктор принимает неизменяемый объект, который будет использоваться
  // в качестве исходного состояния (англ. base state).
  constructor(obj) {
    // Сохраняем исходный объект в свойстве экземпляра.
    this.obj = obj;
  }

  // Метод produce принимает функцию-мутатор, через которую выполняются изменения.
  // Внутри метода используется proxy, чтобы фиксировать изменения в специальной истории.
  produce(mutator) {
    // ---------------------------------------------------------------
    // Функция createProxiedObj рекурсивно строит proxy-обертку для объекта.
    // Параметры:
    //   - obj: исходный объект или массив.
    //   - history: экземпляр AccessHistory для хранения изменений на данном уровне.
    // ---------------------------------------------------------------
    const createProxiedObj = (obj, history) => {
      // Создаем Proxy для объекта, определяя ловушки get и set.
      return new Proxy(obj, {
        // Ловушка set вызывается при присвоении нового значения свойству.
        set(_, prop, value) {
          // Если запись для данного свойства еще не заведена в истории,
          // создаем новый узел истории для этого свойства.
          if (!history.props.has(prop)) {
            history.props.set(prop, new AccessHistory());
          }
          // Сохраняем новое значение в истории, не изменяя оригинальный объект.
          // Например, если выполняется "proxy.val = proxy.val + 1", то новое значение фиксируется здесь.
          history.props.get(prop).value = value;
          // Возвращаем true, указывая, что установка значения прошла успешно.
          return true;
        },

        // Ловушка get вызывается, когда происходит чтение свойства.
        get(target, prop) {
          // Если для текущего узла уже установлено новое значение (запись в history),
          // возвращаем его сразу, игнорируя дальнейшие чтения.
          // Семантика history.value vs history.props
          //   - history.value !== undefined означает «я полностью
          //     заменил этот узел» (например, draft.user = {…} на
          //     draft.user = "строка"). Как только заметили 
          //     history.value, нам не надо: копировать исходный obj,
          //     смотреть props, рекурсивно ходить по детям. Мы сразу
          //     возвращаем готовый результат, куда пользователь
          //     своим set-ом уже «влиял».
          //   - history.props хранит мелкие «латки» — отдельные
          //     свойства, которые меняли через proxy.someProp = ….
          if (history.value !== undefined) return history.value;

          // Если в истории для данного свойства еще нет записи, создаем новый узел истории.
          // Каждый вызов get создаёт запись в history.props не для того, чтобы тут же её использовать,
          // а чтобы у нас была «якорная точка» для вложенных прокси и дальнейшего трекинга их изменений.
          // Без этого:
          //
          // 1. Если мы в теле mutator сделаем что-то вроде:
          //      draft.user.profile.age = 30;
          //    – сначала при чтении draft.user срабатывает get('user'),
          //      который привязывает к свойству user новый узел истории.
          //    – Из этого узла потом формируется прокси для profile, затем для age.
          //
          // 2. Без записи на этапе get('user') просто некуда было бы цеплять историю
          //    для profile и, соответственно, для age — set('age') не зафиксируется.
          //
          // 3. После того как все вложенные операции (чтения и записи) отработают,
          //    мы вызываем pruneHistory и сбрасываем «пустые» узлы — те, в которых
          //    не было реальных вызовов set.
          //
          // Итог:
          //   • get создаёт «фундамент» для трекинга всех вложенных изменений,
          //   • set наполняет этот фундамент реальными значениями,
          //   • pruneHistory убирает то, что осталось ненужным.
          //
          // Без первого шага (get → создание AccessHistory) вложенные присваивания
          // просто не записались бы в историю.

          if (!history.props.has(prop)) {
            history.props.set(prop, new AccessHistory());
          }
          // Получаем историю для конкретного свойства.
          const propHistory = history.props.get(prop);

          // Если для этого свойства уже зафиксировано новое значение, возвращаем его.
          if (propHistory.value !== undefined) {
            return propHistory.value;
          }

          // Получаем оригинальное значение свойства из целевого (target) объекта.
          // Выполняется только когда на текущем уровне history.value === undefined
          // то есть никакого «глобального» перезаписи объекта не было, и при этом
          // для данного свойства propHistory.value тоже ещё не задано.
          const res = target[prop];
          // Если полученное значение является объектом (или массивом),
          // оборачиваем его в proxy для дальнейшего отслеживания вложенных изменений.
          if (isObject(res)) {
            return createProxiedObj(res, propHistory);
          }
          // Если значение примитивное (число, строка, boolean и т.д.), возвращаем его напрямую.
          return res;
        }
      });
    };

    // ---------------------------------------------------------------
    // Функция pruneHistory рекурсивно очищает историю изменений,
    // удаляя ветки, где не произошло реальных изменений.
    // Если в узле истории изменений нет, этот узел удаляется из Map.
    // ---------------------------------------------------------------
    const pruneHistory = (history) => {
      // Если для данного узла зафиксировано новое значение, оно является
      //  изменением – возвращаем true.
      // Семантика history.value vs history.props
      //   - history.value !== undefined означает «я полностью
      //     заменил этот узел» (например, draft.user = {…} на
      //     draft.user = "строка"). Как только заметили 
      //     history.value, нам не надо: копировать исходный obj,
      //     смотреть props, рекурсивно ходить по детям. Мы сразу
      //     возвращаем готовый результат, куда пользователь
      //     своим set-ом уже «влиял».
      //   - history.props хранит мелкие «латки» — отдельные
      //     свойства, которые меняли через proxy.someProp = ….
      if (history.value !== undefined) return true;
      // Флаг, показывающий, были ли в дочерних узлах изменения.
      let changed = false;
      // Итерируемся по всем записям в history.props.
      for (const [prop, childHistory] of history.props) {
        // Если pruneHistory(childHistory) возвращает true,
        // мы не удаляем childHistory из history.props,
        // а помечаем changed = true, чтобы зафиксировать, 
        // что на этом уровне есть хотя бы одна ветка с
        // изменениями.
        // В результате:
        //  1. Любая ветка, где были прямые присвоения
        //     (history.value !== undefined) или хотя бы в
        //     одном из детей есть изменения, будет
        //     возвращать true и сохранится.
        //  2. Ветки без изменений (pruneHistory вернуло
        //     false) будут удалены, чтобы не тащить их
        //     дальше в слияние.
        // Именно благодаря этому мы окончательно
        // избавляемся от «пустых» участков истории.
        if (pruneHistory(childHistory)) {
          // Если изменения обнаружены, ставим флаг.
          changed = true;
        } else {
          // Если для этого свойства изменений нет, удаляем узел из истории.
          history.props.delete(prop);
        }
      }
      // Возвращаем true, если в текущем узле или его потомках были зафиксированы изменения.
      return changed;
    };

    // ---------------------------------------------------------------
    // Сливает исходный объект и накопленные изменения из истории
    // в один новый объект
    // Параметры:
    //   - obj: исходный объект или его часть.
    //   - history: узел истории, содержащий изменения для данного объекта.
    // ---------------------------------------------------------------
    const mergeChanges = (obj, history) => {
      // Если в текущем узле истории есть конкретное новое значение, возвращаем его.
      // Это значит, что текущая ветка была полностью заменена.
      // Семантика history.value vs history.props
      //   - history.value !== undefined означает «я полностью
      //     заменил этот узел» (например, draft.user = {…} на
      //     draft.user = "строка"). Как только заметили 
      //     history.value, нам не надо: копировать исходный obj,
      //     смотреть props, рекурсивно ходить по детям. Мы сразу
      //     возвращаем готовый результат, куда пользователь
      //     своим set-ом уже «влиял».
      //   - history.props хранит мелкие «латки» — отдельные
      //     свойства, которые меняли через proxy.someProp = ….
      if (history.value !== undefined) return history.value;
      // Если у истории нет ни одного дочернего свойства — изменений нет,
      // возвращаем оригинальное значение.
      // Это позволяет не копировать ненужные части объекта.
      if (!history.props.size) return obj;

      // Создаем поверхностную копию объекта или массива.
      // Если obj является массивом, используем метод slice(), иначе деструктуризацию.
      const cloned = Array.isArray(obj)
        ? obj.slice()
        : { ...obj };

      // Подробно:
      //  1. Сначала мы создали shallow-копию (поверхностную
      //     копию) всего объекта через { …obj } или
      //     obj.slice().
      //  2. history.props хранит только те ключи, где были
      //     реальные изменения (либо прямое присвоение
      //     value, либо изменение вложенных свойств).
      //  3. Цикл проходит лишь по ним и перезаписывает в
      //     cloned только те поля, которые изменились.
      //  4. Для каждого такого поля вызывается 
      //     mergeChanges рекурсивно:
      //       – если ветка перезаписана целиком, вернётся
      //         новое значение;
      //       – иначе будут скопированы и переписаны только
      //         её изменённые дочерние поля.
      // В результате: 
      //   - В cloned оказываются обновлённые свойства,
      //   - А все неизменённые свойства продолжают 
      //     ссылаться на оригинал (частичное шарирование).
      // Именно так достигается инициальная цель — получить
      // новый объект с минимальным копированием данных.
      for (const [prop, childHistory] of history.props) {
        // Для каждого свойства рекурсивно объединяем изменения.
        // Например, если изменялось вложенное свойство, это
        // обеспечит правильную глубинную замену.
        cloned[prop] = mergeChanges(obj[prop], childHistory);
      }
      // Возвращаем новый объект с внесенными изменениями.
      return cloned;
    };

    // ---------------------------------------------------------------
    // Создаем корневой узел истории для отслеживания изменений всего объекта.
    // Это начальная точка для всех последующих запросов через proxy.
    // ---------------------------------------------------------------
    const accessHistory = new AccessHistory();

    // Создаем прокси-объект для исходного объекта this.obj,
    // привязывая к нему созданную историю (accessHistory).
    // При вызове мутационной функции все обращения к proxy будут фиксироваться в accessHistory.
    const proxy = createProxiedObj(this.obj, accessHistory);

    // Вызываем функцию-мутатор с proxy в качестве аргумента.
    // Все присваивания или изменения внутри mutator будут записаны через ловушки proxy.
    // Пример: если mutator выполнит proxy.val += 1, это изменение будет сохранено в history.
    mutator(proxy);

    // Вызываем pruneHistory, чтобы очистить неиспользуемые
    // ветки истории,
    // тем самым оптимизируя будущий merge изменений.
    // Мы вызываем pruneHistory сразу после выполнения
    // mutator(proxy) потому что только к этому моменту у
    // нас есть полная картина: какие свойства реально
    // изменялись, а какие были просто прочитаны 
    // (или вовсе не затронуты).
    pruneHistory(accessHistory);

    // На основе зафиксированных изменений в accessHistory создаем новый объект,
    // в котором внесены все изменения, а оригинальный объект this.obj остается неизменным.
    return mergeChanges(this.obj, accessHistory);
  }
}








// Вспомогательная функция assert, выбрасывающая ошибку, если условие не выполнено.
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

/*
  Тестовые кейсы для класса ImmutableHelper.
  Перед запуском тестов убедитесь, что класс ImmutableHelper (и класс AccessHistory)
  описаны выше, и доступны в этом контексте.
*/
const tests = [
  {
    description: "Простая модификация свойства: увеличение значения",
    async test() {
      const original = { val: 10 };
      const helper = new ImmutableHelper(original);
      // Изменяем свойство val, увеличивая его значение на 1.
      const result = helper.produce(proxy => {
        proxy.val += 1; // 10 + 1 = 11
      });
      const expected = { val: 11 };
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
      // Проверяем, что оригинальный объект не изменился.
      assert(
        JSON.stringify(original) === JSON.stringify({ val: 10 }),
        "Оригинальный объект должен остаться неизменным"
      );
    },
  },
  {
    description: "Добавление нового свойства",
    async test() {
      const original = { val: 10 };
      const helper = new ImmutableHelper(original);
      const result = helper.produce(proxy => {
        // Добавляем новое свойство newProp со значением 100.
        proxy.newProp = 100;
      });
      const expected = { val: 10, newProp: 100 };
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
      // Проверяем, что оригинальный объект не содержит нового свойства.
      assert(
        !("newProp" in original),
        "Оригинальный объект не должен содержать ключ newProp"
      );
    },
  },
  {
    description: "Модификация массива внутри объекта",
    async test() {
      const original = { arr: [1, 2, 3] };
      const helper = new ImmutableHelper(original);
      const result = helper.produce(proxy => {
        // Меняем первый элемент массива с 1 на 5.
        proxy.arr[0] = 5;
        // Добавляем новое свойство newVal, равное сумме первого и второго элементов массива: 5 + 2 = 7.
        proxy.newVal = proxy.arr[0] + proxy.arr[1];
      });
      const expected = { arr: [5, 2, 3], newVal: 7 };
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
      // Проверяем, что оригинальный объект остаётся без изменений.
      assert(
        JSON.stringify(original) === JSON.stringify({ arr: [1, 2, 3] }),
        "Оригинальный объект не должен изменяться"
      );
    },
  },
  {
    description: "Модификация вложенного объекта: обмен значений",
    async test() {
      const original = { obj: { val: { x: 10, y: 20 } } };
      const helper = new ImmutableHelper(original);
      const result = helper.produce(proxy => {
        // Получаем проксированную версию вложенного объекта.
        const data = proxy.obj.val;
        // Обмен значений x и y.
        const temp = data.x;
        data.x = data.y;
        data.y = temp;
      });
      const expected = { obj: { val: { x: 20, y: 10 } } };
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
      // Проверяем, что оригинальный объект остаётся неизменённым.
      assert(
        JSON.stringify(original) === JSON.stringify({ obj: { val: { x: 10, y: 20 } } }),
        "Оригинальный объект должен остаться неизменным"
      );
    },
  },
  {
    description: "Производство без изменений",
    async test() {
      const original = { a: 1, b: 2 };
      const helper = new ImmutableHelper(original);
      // Функция-мутатор не делает никаких изменений.
      const result = helper.produce(proxy => {
        // Нет изменений
      });
      // Результат должен совпадать с исходным объектом.
      assert(
        JSON.stringify(result) === JSON.stringify(original),
        `Ожидалось ${JSON.stringify(original)}, получено ${JSON.stringify(result)}`
      );
    },
  },
  {
    description: "Модификация вложенной структуры с добавлением нового ключа",
    async test() {
      const original = { a: { b: [1, 2] } };
      const helper = new ImmutableHelper(original);
      const result = helper.produce(proxy => {
        // Меняем второй элемент вложенного массива с 2 на 3.
        proxy.a.b[1] = 3;
        // Добавляем новое свойство newField со значением "test" во вложенный объект a.
        proxy.a.newField = "test";
      });
      const expected = { a: { b: [1, 3], newField: "test" } };
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
      // Проверяем, что исходный объект не изменился.
      assert(
        JSON.stringify(original) === JSON.stringify({ a: { b: [1, 2] } }),
        "Оригинальный объект должен остаться без изменений"
      );
    },
  },
  {
    description: "Независимость последовательных produce вызовов",
    async test() {
      const original = { val: 5 };
      const helper = new ImmutableHelper(original);
      // Первый вызов produce: прибавляем 5 -> 5 + 5 = 10.
      const result1 = helper.produce(proxy => {
        proxy.val = proxy.val + 5;
      });
      // Второй вызов produce: умножаем начальное значение на 2 -> 5 * 2 = 10.
      const result2 = helper.produce(proxy => {
        proxy.val = proxy.val * 2;
      });
      const expected1 = { val: 10 };
      const expected2 = { val: 10 };
      assert(
        JSON.stringify(result1) === JSON.stringify(expected1),
        `Ожидалось ${JSON.stringify(expected1)}, получено ${JSON.stringify(result1)}`
      );
      assert(
        JSON.stringify(result2) === JSON.stringify(expected2),
        `Ожидалось ${JSON.stringify(expected2)}, получено ${JSON.stringify(result2)}`
      );
      // Проверяем, что оригинальный объект не изменился после последовательных produce вызовов.
      assert(
        JSON.stringify(original) === JSON.stringify({ val: 5 }),
        "Оригинальный объект не должен изменяться"
      );
    },
  },
];

// Запуск тестов.
(async () => {
  console.log("Запуск тестов для ImmutableHelper...");
  let hasErrors = false;
  for (let i = 0; i < tests.length; i++) {
    try {
      await tests[i].test();
      console.log(`✔️  Тест ${i + 1} пройден: ${tests[i].description}`);
    } catch (e) {
      hasErrors = true;
      console.error(`❌ Тест ${i + 1} не пройден: ${tests[i].description}`);
      console.error(e);
    }
  }
  if (hasErrors) {
    console.error("❗ Некоторые тесты завершились с ошибкой.");
  } else {
    console.log("🎉 Все тесты для ImmutableHelper завершены успешно.");
  }
})();