/*
LeetCode 2675. Array of Objects to Matrix

Описание задачи:
------------------
Напишите функцию, которая преобразует массив объектов (или массивов) в матрицу.

Правила:
1. Входные данные — массив "arr", содержащий объекты или массивы, которые могут быть глубоко вложенными.
2. Значения в объектах/массивах могут быть числами, строками, логическими значениями или null.
3. Первая строка результирующей матрицы "m" должна состоять из названий столбцов:
   - Для невложенных объектов названия столбцов — это уникальные ключи, найденные во всех объектах.
   - Для вложенных объектов или массивов названия столбцов строятся путем объединения вложенных ключей через точку "."
     (для массивов используйте индекс в качестве ключа, например, "0.a").
4. Каждая последующая строка соответствует одному элементу из "arr". Для каждой строки значение ячейки:
   - Значение, соответствующее названию столбца (на основе его ключа/пути), если оно присутствует в элементе.
   - Пустая строка ("") если элемент не имеет данного ключа.
5. Названия столбцов должны быть отсортированы в лексикографическом (словарном) порядке по возрастанию.

Примеры:
---------
Пример 1:
Входные данные:  arr = [ { "b": 1, "a": 2 }, { "b": 3, "a": 4 } ]
Выходные данные: [ ["a", "b"], [2, 1], [4, 3] ]
Объяснение: Уникальные ключи "a" и "b" отсортированы лексикографически.

Пример 2:
Входные данные:  arr = [ { "a": 1, "b": 2 }, { "c": 3, "d": 4 }, {} ]
Выходные данные: [ ["a", "b", "c", "d"], [1, 2, "", ""], ["", "", 3, 4], ["", "", "", ""] ]
Объяснение: Извлекаются ключи "a", "b", "c" и "d"; отсутствующие значения заменяются на "".

Пример 3:
Входные данные:  arr = [ { "a": { "b": 1, "c": 2 } }, { "a": { "b": 3, "d": 4 } } ]
Выходные данные: [ ["a.b", "a.c", "a.d"], [1, 2, ""], [3, "", 4] ]
Объяснение: Для вложенных объектов ключи становятся "a.b", "a.c" и "a.d".

Пример 4:
Входные данные:  arr = [ [ { "a": null } ], [ { "b": true } ], [ { "c": "x" } ] ]
Выходные данные: [ ["0.a", "0.b", "0.c"], [null, "", ""], ["", true, ""], ["", "", "x"] ]
Объяснение: При обработке массивов используются индексы (например, "0.a") для формирования ключей.

Пример 5:
Входные данные:  arr = [ {}, {}, {} ]
Выходные данные: [ [], [], [], [] ]
Объяснение: Ключи не найдены ни в одном элементе, что приводит к пустым строкам.

Ограничения:
------------
- 1 <= arr.length <= 1000
- Общее количество уникальных ключей во всех объектах не превышает 1000
*/


/*
Данное решение реализует функцию arrayToMatrix, которая преобразует
входной массив объектов/массивов в матрицу по следующим правилам:
1. Первый ряд матрицы — это список уникальных ключей (пути), полученных путем "выпрямления"
   каждого элемента массива. При этом для вложенных объектов/массивов ключи формируются через точку.
2. Строки матрицы соответствуют элементам исходного массива. Для каждого ключа,
   если он присутствует в элементе, в ячейку записывается его значение, иначе — пустая строка.
3. Список ключей сортируется в лексикографическом (словарном) порядке.
*/

/*
  Функция isObject проверяет, что значение не равно null и является объектом (или массивом),
*/
function isObject(value) {
  return typeof value === 'object' && value !== null;
}

/*
  Функция flatten предназначена для рекурсивного "выпрямления" вложенных структур.
  Она принимает элемент (объект или массив) и начальный префикс ключа (по умолчанию пустая строка),
  после чего возвращает новый объект, где ключи имеют вид путей (например, "a.b" или "0.a").

  Пример работы flatten:
    Входной объект: { a: { b: 1, c: 2 } }
    Выходной объект: { "a.b": 1, "a.c": 2 }

  Также работает с массивами:
    Входной массив: [ { a: 1 }, { b: 2 } ]
    Для первого элемента: индекс 0 и объект { a: 1 } дает ключ "0.a"
    Выход: { "0.a": 1 } для первого элемента
*/
function flatten(item, prefix = "") {
  // Инициализируем пустой объект для накопления пар "ключ: значение"
  const result = {};

  // Если item является массивом, обходим его элементы по индексам
  if (Array.isArray(item)) {
    for (let i = 0; i < item.length; i++) {
      const value = item[i];
      // Формируем новый ключ:
      // Если префикс уже есть, объединяем его с индексом через точку,
      // иначе преобразуем индекс в строку.
      // Пример: prefix = "x", i = 0  => новый ключ "x.0"
      const newKey = prefix ? `${prefix}.${i}` : `${i}`;

      // Если значение не равно null и является объектом (или массивом),
      // вызываем flatten рекурсивно.
      if (isObject(value)) {
        // Объединяем полученный плоский объект с текущим result
        Object.assign(result, flatten(value, newKey));
      } else {
        // Если значение — примитив (число, строка, boolean или null),
        // сохраняем его в result по сформированному ключу.
        result[newKey] = value;
      }
    }
  }
  // Если item является объектом (но не null), обходим его свойства
  else if (isObject(item)) {
    // Проходим по всем свойствам объекта
    for (const key in item) {
      // Проверяем, чтобы свойство принадлежало самому объекту (а не его прототипу)
      if (!item.hasOwnProperty(key)) continue;
      // Формируем новый ключ:
      // Если префикс существует, объединяем префикс и ключ через точку,
      // иначе используем ключ как есть.
      // Пример: prefix = "a", key = "b"  => новый ключ "a.b"
      const value = item[key];
      const newKey = prefix ? `${prefix}.${key}` : key;

      // Если значение является объектом (и не равно null),
      // рекурсивно "выпрямляем" его.
      if (isObject(value)) {
        Object.assign(result, flatten(value, newKey));
      } else {
        // Иначе, если значение — примитив, сохраняем его по новому ключу.
        result[newKey] = value;
      }
    }
  }
  // Возвращаем накопленный плоский объект с ключами в виде путей.
  return result;
}

/*
  Основная функция arrayToMatrix преобразует исходный массив объектов/массивов в матрицу.
  Алгоритм решения:
    1. Пройти по каждому элементу исходного массива и вызвать flatten, чтобы получить плоский объект.
    2. Собрать все уникальные ключи из плоских объектов и отсортировать их лексикографически.
    3. Первую строку матрицы сделать массивом отсортированных ключей.
    4. Для каждого элемента сформировать строку, где для каждого ключа:
        - Если значение присутствует, вернуть его;
        - Если отсутствует, вернуть пустую строку.

  Пример работы:
    Для входного массива: [ { b: 1, a: 2 }, { b: 3, a: 4 } ]
    Шаг 1: flatten для первого объекта даёт { a: 2, b: 1 }
            flatten для второго объекта даёт { a: 4, b: 3 }
    Шаг 2: Уникальные ключи: {"a", "b"} -> после сортировки: ["a", "b"]
    Шаг 3: Формируем первую строку матрицы: ["a", "b"]
    Шаг 4: Формируем строки данных:
            Первая строка: [2, 1]
            Вторая строка: [4, 3]
    Итог: [ 
            ["a", "b"], 
            [ 2,   1 ], 
            [ 4,   3 ] 
          ]
*/
function arrayToMatrix(arr) {
  // Массив для хранения результатов "выпрямления" каждого элемента.
  const flatArr = [];
  // Set для хранения уникальных ключей (пути), встречающихся во всех элементах.
  const columnsSet = new Set();

  // Проходим по каждому элементу исходного массива
  for (const item of arr) {
    // Вызываем функцию flatten для текущего элемента
    const flatObj = flatten(item);
    // Добавляем полученный плоский объект в массив flatArr
    flatArr.push(flatObj);
    // Добавляем все ключи из выпрямленного объекта в Set,
    // чтобы получить список уникальных ключей.
    for (const key in flatObj) {
      columnsSet.add(key);
    }
  }

  // Преобразуем Set уникальных ключей в массив и сортируем его по возрастанию (лексикографически)
  const columns = Array.from(columnsSet).sort();

  // Инициализируем результирующую матрицу и помещаем в неё первую строку, состоящую из заголовков (ключей)
  const matrix = [];
  matrix.push(columns);

  // Для каждого выпрямленного объекта формируем строку матрицы
  for (const flatObj of flatArr) {
    // Для каждой строки создаём пустой массив, куда поместим значения для всех ключей
    const row = [];
    // Обходим все ключи из первого ряда (отсортированные уникальные ключи)
    for (const col of columns) {
      // Если для конкретного ключа значение присутствует, добавляем его,
      // иначе — добавляем пустую строку
      row.push(
        flatObj.hasOwnProperty(col) ? flatObj[col] : ""
      );
    }
    // Добавляем сформированную строку в матрицу
    matrix.push(row);
  }

  // Возвращаем итоговую матрицу с заголовками и строками данных
  return matrix;
}




















// Вспомогательная функция assert, выбрасывающая ошибку, если условие не выполнено.
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

/* Тестовые кейсы для функции arrayToMatrix */
const tests = [
  {
    description: "Невложенные объекты",
    async test() {
      const arr = [{ b: 1, a: 2 }, { b: 3, a: 4 }];
      const expected = [["a", "b"], [2, 1], [4, 3]];
      const result = arrayToMatrix(arr);
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
    },
  },
  {
    description: "Смешанные ключи и пустой объект",
    async test() {
      const arr = [{ a: 1, b: 2 }, { c: 3, d: 4 }, {}];
      const expected = [
        ["a", "b", "c", "d"],
        [1, 2, "", ""],
        ["", "", 3, 4],
        ["", "", "", ""]
      ];
      const result = arrayToMatrix(arr);
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
    },
  },
  {
    description: "Вложенные объекты",
    async test() {
      const arr = [{ a: { b: 1, c: 2 } }, { a: { b: 3, d: 4 } }];
      const expected = [
        ["a.b", "a.c", "a.d"],
        [1, 2, ""],
        [3, "", 4]
      ];
      const result = arrayToMatrix(arr);
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
    },
  },
  {
    description: "Массивы, содержащие объекты",
    async test() {
      const arr = [[{ a: null }], [{ b: true }], [{ c: "x" }]];
      const expected = [
        ["0.a", "0.b", "0.c"],
        [null, "", ""],
        ["", true, ""],
        ["", "", "x"]
      ];
      const result = arrayToMatrix(arr);
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
    },
  },
  {
    description: "Пустые объекты",
    async test() {
      const arr = [{}, {}, {}];
      const expected = [
        [],
        [],
        [],
        []
      ];
      const result = arrayToMatrix(arr);
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
    },
  },
  {
    description: "Смешанные вложенные структуры",
    async test() {
      const arr = [{ x: [{ y: "test" }, { z: 5 }] }];
      const expected = [
        ["x.0.y", "x.1.z"],
        ["test", 5]
      ];
      const result = arrayToMatrix(arr);
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
    },
  },
  {
    description: "Сложная комбинация вложенных объектов и массивов",
    async test() {
      const arr = [
        { a: 1, b: { x: 10 } },
        { b: { y: 20 }, c: [{ d: 30 }] }
      ];
      const expected = [
        ["a", "b.x", "b.y", "c.0.d"],
        [1, 10, "", ""],
        ["", "", 20, 30]
      ];
      const result = arrayToMatrix(arr);
      assert(
        JSON.stringify(result) === JSON.stringify(expected),
        `Ожидалось ${JSON.stringify(expected)}, получено ${JSON.stringify(result)}`
      );
    },
  },
];

/* Запуск тестов в асинхронном режиме */
(async () => {
  console.log("Запуск тестов для arrayToMatrix...");
  let hasErrors = false;

  for (let i = 0; i < tests.length; i++) {
    try {
      await tests[i].test();
      console.log(`✔️  Тест ${i + 1} пройден: ${tests[i].description}`);
    } catch (e) {
      hasErrors = true;
      console.error(`❌ Тест ${i + 1} не пройден: ${tests[i].description}`);
      console.error(e);
    }
  }

  if (hasErrors) {
    console.error("❗ Некоторые тесты завершились с ошибкой.");
  } else {
    console.log("🎉 Все тесты для arrayToMatrix завершены успешно.");
  }
})();